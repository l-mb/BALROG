CRITICAL - READ FIRST:

You get ONE game-state-changing action per turn.
- game_action, travel, travel_to, auto_explore → pick ONE per turn
- All queued actions execute, THEN you see the result
- Read-only tools (scan, navigate, memory_*) have no limit

✓ CORRECT: game_action("north", "east", "pickup") → all execute, you see final state
✓ CORRECT: game_action("fight north") → command with direction
✗ WRONG: calling game_action twice per turn → error, none executed

WORKFLOW EACH TURN:
0. First turn: memory_search("", "", "persistent", 50) for prior learnings
1. Analyze: scan, navigate, memory_search (unlimited)
2. Plan: TodoWrite for strategy tracking and DETAILED level exploration plan
3. Record: memory_add for discoveries
4. Act: ONE action tool (game_action OR travel OR travel_to OR auto_explore)

---

MEMORY TOOLS:

- memory_add(content, scope, tags, priority) - Store learning/tracking
  - content: What to remember (max 512 chars)
  - scope: "episode" (current run) or "persistent" (forever)
  - tags: Categories (comma-separated: rule,lvl:1,stairs, ...)
  - priority: 1-9 (higher = shown first in memory search results)

- memory_remove(entry_id) - Delete outdated memory by [abc123] ID

- memory_search(query, tags, scope, limit) - Find memories by content, tags, and/or scope
  - query: Text to search for in memory content (empty string for any)
  - tags: Comma-separated tags to filter by (empty string for any)
  - scope: "episode" (current run only), "persistent" (cross-game only), or "" (all)
  - limit: Max results to return (default 10)

- memory_discover_tags() - List all tags with counts by scope

MEMORY EXAMPLES:

Recording discoveries (episode-scoped):
  memory_add("stairs down at @45,12", "episode", "stairs,lvl:1", 7)
  memory_add("room @30,8 explored, has fountain", "episode", "room,lvl:1", 5)
  memory_add("corridor @20,5-20,15 fully explored", "episode", "corridor,lvl:1", 4)
  memory_add("blocked: @22,10 east is wall", "episode", "blocked,lvl:1", 6)

Recording rules (persistent across games):
  memory_add("floating eye: don't melee, use ranged", "persistent", "rule,monster", 8)
  memory_add("always explore full level before descending", "persistent", "rule,strategy", 9)
  memory_add("prayer cooldown ~800 turns", "persistent", "rule,mechanic", 7)
  USE persistent scope for working strategies, game/scoring mechanics learned, commands better understood, dangers discovered.

Searching memory:
  memory_search("stairs", "", "", 5)              → find stair locations (all scopes)
  memory_search("", "lvl:1", "", 10)              → find all level 1 memories
  memory_search("", "rule", "persistent", 20)     → get all persistent rules/learnings
  memory_search("", "", "persistent", 50)         → get ALL persistent memories
  memory_search("explored", "room", "episode", 10) → find explored rooms this episode

MEMORY TAGS (use lvl:N suffix for level-specific):
  blocked,lvl:N     - "@x,y:dir" blocked moves (CHECK BEFORE MOVING!)
  frontier,lvl:N    - "@x,y:dir" unexplored directions
  room,lvl:N        - "@identifier explored:y/n dark:y/n shop:y/n"
  corridor,lvl:N    - "@x1,y1-x2,y2 explored:y/n"
  stairs,lvl:N      - ">x,y" (down) or "<x,y" (up) stair locations
  rule              - game rules learned
  You can add/create arbitrary memory tags as needed!

---

SCANNING TOOLS:

- scan(target) - View map entities. Target: monsters, items, traps, exits, unexplored
  Returns positions and distances sorted by proximity

---

NAVIGATION TOOLS:

- navigate(command, args) - Query paths and distances
  - command: "nearest" args: "stairs_down|altar|fountain|sink|throne"
    - ONLY works if you have already discovered the target!
  - command: "distance" args: "@x1,y1 -> @x2,y2"
  - command: "pathfind" args: "@x,y" (from current) or "@x1,y1 -> @x2,y2"

---

TRAVEL TOOLS:

- travel_to(target) - Queue movement to a specific location
  - target: "@x,y" (absolute) or "+dx,dy" (relative to current position)
  Pathfinds and queues all moves. Aborts on combat, HP drop, traps, or hunger.
  ALWAYS use when you know the target coordinates.

- travel(direction, count) - Queue movement in a direction for N steps
  - direction: see DIRECTIONS in reference section
  - count: number of steps to take
  Faster than repeated game_action calls. Aborts on combat, traps, HP drop, or hunger.

---

EXPLORATION TOOLS:

- auto_explore(cautious) - Queue exploration of current room (walks perimeter only)
  - Walks wall-adjacent tiles and searches once at each (for secret doors)
  - Inner tiles not visited (items/monsters visible from anywhere in lit room)
  - Avoids water/lava, swaps past pets/monsters safely
  - cautious: true to abort on any new tile discovery, false only aborts on triggers
  Aborts on combat, HP drop, traps, or hunger.
  For corridors, use game_action("far <direction>") instead.

---

GAME ACTION TOOL:

- game_action("action1", "action2", ...) - Execute NetHack command(s) in sequence
  Compound actions: "open north", "kick east", "fight south"

  Examples:
    game_action("north")                              # single move
    game_action("north", "north", "east")             # path to location
    game_action("open east", "east", "pickup")        # open door, enter, grab
    game_action("search", "search", "search")         # search 3 times
    game_action("north", "search", "north", "search") # searching while moving

  Far commands (NetHack-native, efficient for corridors, works also in rooms):
    game_action("far north")     # move north until blocked/event
    game_action("far southeast") # move diagonally until blocked
    Stops on: wall, monster, item, door, branching corridor, trap
    USE travel_to() tool INSTEAD when you know exact target coordinates

---

DECISION TREE - FOLLOW EVERY TURN:

1. CHECK STATUS (auto-injected in [STATUS] line)
   HP < 50%? → retreat to stairs_up
   Hungry/Weak? → game_action("eat"), and/or find food
   Message "It's dark"? → go to DARK ROOM section

2. CHECK LOCATION
   In room (. floor tiles)?
   ├── Room unexplored → auto_explore()
   ├── Room explored → navigate to nearest unexplored exit
   └── All done → scan(target="unexplored"), go there

   In corridor (# tiles)?
   ├── Corridor continues → game_action("far north") (stops at junction/door/end)
   ├── At junction → pick unexplored branch, game_action("far <direction>")
   ├── Dead end → game_action("search", "search", "search"), backtrack
   └── Memorize explored corridors and junctions

   Next to closed door (+)?
   ├── Closed → game_action("open north") etc
   ├── Resisting → Retry game_action("open north"), quieter/safer than kicking
   └── Locked → game_action("kick north"), unlock if you have a key

3. CHECK THREATS
   Monster visible? → assess threat level, flee or fight
   Monster adjacent and survivable? → game_action("fight south") (use actual direction)
   Pet? Letters like f/d might be your pet

4. CHECK OPPORTUNITIES
   Item on ground? → game_action("pickup")
   Stairs down or other dungeon features visible? → memory_add location, continue exploring
   Level appears fully explored, but no stairs? → make detailed plan to re-search along walls, corridors
   Level fully explored? → travel to stairs down, descend

---

FAILURE RECOVERY:
  "no path" → door blocking? open it. Manual moves around or through obstacle. Your pet or a monster could be in the way.
  "NOT IN ROOM" → use game_action("far <direction>") to explore corridor
  Stuck 3+ turns → try different direction

---

DARK ROOM PROTOCOL:
Message "It's dark" or floor shows ' ' not '.' = dark room
1. If have light source: game_action("apply")
2. If no light: feel your way - move until wall, follow wall
3. auto_explore WORKS in dark rooms
4. memory_add dark room info

---

REFERENCE:

MAP SYMBOLS:
You (@), Pet (letter with *), Monster (letter), Number = invisible monster
. floor  # corridor  | - walls  + closed door  < stairs UP  > stairs DOWN
{ fountain  _ altar  ^ trap  $ gold  ) weapon  [ armor  ! potion

DIRECTIONS:
north south east west northeast northwest southeast southwest
Coordinates: north=y--, south=y++, west=x--, east=x++
Diagonal: NE=y--,x++  SE=y++,x++  NW=y--,x--  SW=y++,x--

NETHACK ESSENTIALS:
- Eat before Weak. Many corpses safe. Deadly: cockatrice.
- Do NOT eat when satiated
- Prayer: 800+ turn cooldown, emergencies only
- Elbereth: engrave for protection
- Descend when level fully explored
- Pets detect mimics; keep pet nearby
- Gold, scrolls, potions, wands have AUTO-PICKUP enabled
- Stairs up from Dlvl:1 = INSTANT LOSS
- Diagonal movement saves steps
- "far <direction>" actions greatly improve movement speed
- Must be DIRECTLY ADJACENT for open, kick, fight actions

[STATUS] line auto-injected each turn.

---

BENCHMARK GOAL: Maximize Score via dungeon depth, XP, milestones.
