<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BRAID Monitor</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <script src="https://unpkg.com/htmx.org@2.0.4"></script>
  <link rel="stylesheet" href="/static/style.css" id="app-css">
</head>
<body>
  <main class="container-fluid">
    <!-- Stats bar with nav controls (static) + stats (swapped) -->
    <div class="stats-bar">
      <div class="stats-row">
        <!-- Navigation controls - static, not swapped -->
        <div class="nav-controls">
          <select id="agent-select" class="agent-select" onchange="selectAgent(this.value)">
            {% for agent in agents %}
            <option value="{{ agent.worker_id }}" {% if agent.worker_id == selected %}selected{% endif %}>
              {{ agent.worker_id }} (ep{{ agent.episode }}:{{ agent.step }})
            </option>
            {% endfor %}
            {% if not agents %}
            <option value="">No agents</option>
            {% endif %}
          </select>
          <label class="auto-refresh-toggle">
            <input type="checkbox" id="autorefresh" checked onchange="toggleAutoRefresh(this.checked)">
            Auto
          </label>
          <div id="step-nav" class="step-nav hidden">
            <button id="btn-back10" title="-10 (hold: first)">&laquo;</button>
            <button id="btn-back1" title="-1">&lsaquo;</button>
            <span id="step-display">-/-</span>
            <button id="btn-fwd1" title="+1">&rsaquo;</button>
            <button id="btn-fwd10" title="+10 (hold: latest)">&raquo;</button>
            <button id="play-btn" onclick="togglePlayback()" title="Play">&#9654;</button>
          </div>
        </div>
        <!-- Stats - swapped via htmx -->
        <div id="stats-content" class="stats-content">
          <!-- Initial loading placeholder -->
          <span class="muted">Loading...</span>
        </div>
      </div>
    </div>

    <!-- Main panels - swapped via htmx -->
    <div id="panels"
         hx-get="/partials/all/{{ selected }}"
         hx-trigger="load, every 500ms"
         hx-swap="innerHTML">
      <!-- Panels loaded via htmx -->
    </div>
  </main>

  <script>
    // Selected agent
    let selectedAgent = '{{ selected }}';

    // Preserve scroll positions across htmx swaps
    let scrollPositions = {};

    document.body.addEventListener('htmx:beforeSwap', function(evt) {
      // Save scroll positions of scrollable elements
      document.querySelectorAll('.memory-list, .conversation-content').forEach(el => {
        const key = (el.closest('article')?.className || '') + ' ' + el.className;
        scrollPositions[key] = el.scrollTop;
      });
    });

    document.body.addEventListener('htmx:afterSwap', function(evt) {
      // Restore scroll positions
      document.querySelectorAll('.memory-list, .conversation-content').forEach(el => {
        const key = (el.closest('article')?.className || '') + ' ' + el.className;
        if (scrollPositions[key] !== undefined) {
          el.scrollTop = scrollPositions[key];
        }
      });
    });

    // Step navigation state
    let currentStep = null;  // null = latest
    let maxStep = 0;

    function triggerRefresh() {
      const panels = document.getElementById('panels');
      const url = panels.getAttribute('hx-get');
      // Set flag to bypass interaction pause for this manual refresh
      manualRefreshInProgress = true;
      // Directly make the htmx request instead of relying on trigger events
      htmx.ajax('GET', url, {target: '#panels', swap: 'innerHTML'});
    }

    function selectAgent(agentId) {
      selectedAgent = agentId;
      currentStep = null;  // Reset to latest when switching agents
      maxStep = 0;
      updatePanelsUrl();
      // Update URL bar
      const url = new URL(window.location);
      url.searchParams.set('agent', agentId);
      window.history.replaceState({}, '', url);
      // Trigger immediate refresh
      triggerRefresh();
    }

    function toggleAutoRefresh(enabled) {
      const panels = document.getElementById('panels');
      const stepNavEl = document.getElementById('step-nav');
      if (enabled) {
        stopPlayback();
        panels.setAttribute('hx-trigger', 'load, every 500ms');
        if (stepNavEl) stepNavEl.classList.add('hidden');
        currentStep = null;
        updatePanelsUrl();
      } else {
        // Disable polling - manual refresh via triggerRefresh() using htmx.ajax
        panels.setAttribute('hx-trigger', 'none');
        if (stepNavEl) stepNavEl.classList.remove('hidden');
      }
      htmx.process(panels);
    }

    function stepNav(delta, fromPlayback = false) {
      // Stop playback on manual navigation
      if (!fromPlayback && playbackInterval) {
        stopPlayback();
      }

      if (delta === Infinity) {
        currentStep = null;  // Go to latest (live)
      } else if (delta === -Infinity) {
        currentStep = 1;  // Go to first step
      } else {
        if (currentStep === null) {
          currentStep = maxStep;
        }
        currentStep = Math.max(1, Math.min(maxStep, currentStep + delta));
      }
      updatePanelsUrl();
      // Trigger immediate refresh
      triggerRefresh();
    }

    function updateStepDisplay() {
      const display = document.getElementById('step-display');
      if (display) {
        if (currentStep === null) {
          display.textContent = `${maxStep}/${maxStep} (live)`;
        } else {
          display.textContent = `${currentStep}/${maxStep}`;
        }
      }
    }

    // Playback state
    let playbackInterval = null;

    function togglePlayback() {
      if (playbackInterval) {
        stopPlayback();
      } else {
        startPlayback();
      }
    }

    function startPlayback() {
      const btn = document.getElementById('play-btn');
      if (btn) btn.innerHTML = '&#9724;';  // Pause symbol (square)

      // If at latest, start from beginning
      if (currentStep === null || currentStep >= maxStep) {
        currentStep = 1;
        updatePanelsUrl();
      }

      playbackInterval = setInterval(() => {
        if (currentStep === null || currentStep >= maxStep) {
          stopPlayback();
          return;
        }
        stepNav(1, true);
      }, 500);
    }

    function stopPlayback() {
      if (playbackInterval) {
        clearInterval(playbackInterval);
        playbackInterval = null;
      }
      const btn = document.getElementById('play-btn');
      if (btn) btn.innerHTML = '&#9654;';  // Play symbol (triangle)
    }

    // Periodically refresh agent list to show new agents/episodes
    async function refreshAgentList() {
      try {
        const response = await fetch('/partials/agents?agent=' + encodeURIComponent(selectedAgent));
        if (response.ok) {
          const html = await response.text();
          const select = document.getElementById('agent-select');
          if (!select) return;
          const currentValue = select.value;
          select.innerHTML = html;
          // Restore selection (might have new options now)
          if (select.querySelector(`option[value="${selectedAgent}"]`)) {
            select.value = selectedAgent;
          } else if (select.options.length > 0) {
            // Selected agent no longer exists, switch to first
            selectedAgent = select.options[0].value;
            select.value = selectedAgent;
            updatePanelsUrl();
          }
        }
      } catch (e) {
        console.error('Failed to refresh agent list:', e);
      }
    }

    // Refresh agent list every 5 seconds (dropdown is pre-populated on page load)
    setInterval(refreshAgentList, 5000);

    // Memory filter state
    let memoryScope = 'all';
    let showDeleted = false;

    // Interaction pause - prevent auto-refresh during user interaction
    let interactionPauseUntil = 0;
    const INTERACTION_PAUSE_MS = 2000;
    let manualRefreshInProgress = false;  // Flag to bypass pause for manual refreshes

    function pauseRefresh() {
      interactionPauseUntil = Date.now() + INTERACTION_PAUSE_MS;
    }

    // Block htmx requests while user is interacting (but allow manual refreshes)
    document.body.addEventListener('htmx:beforeRequest', function(evt) {
      if (manualRefreshInProgress) {
        manualRefreshInProgress = false;  // Reset flag
        return;  // Allow this request
      }
      if (Date.now() < interactionPauseUntil) {
        evt.preventDefault();
      }
    });

    function updateMemoryFilter() {
      const scopeSelect = document.querySelector('.memory-scope-select');
      const deletedCheckbox = document.querySelector('.memory-deleted-toggle input');
      if (scopeSelect) memoryScope = scopeSelect.value;
      if (deletedCheckbox) showDeleted = deletedCheckbox.checked;
      updatePanelsUrl();
    }

    function updatePanelsUrl() {
      const panels = document.getElementById('panels');
      const baseUrl = `/partials/all/${selectedAgent}`;
      const params = new URLSearchParams();
      if (memoryScope !== 'all') params.set('scope', memoryScope);
      if (showDeleted) params.set('deleted', '1');
      if (currentStep !== null) params.set('step', currentStep.toString());
      const newUrl = params.toString() ? `${baseUrl}?${params}` : baseUrl;
      panels.setAttribute('hx-get', newUrl);
      htmx.process(panels);
    }

    // Pause refresh when interacting with controls or scrollable areas
    document.body.addEventListener('focusin', function(evt) {
      if (evt.target.closest('.memory-controls, .agent-select, .nav-controls')) {
        pauseRefresh();
      }
    });

    document.body.addEventListener('mousedown', function(evt) {
      if (evt.target.closest('.memory-controls, .nav-controls, .memory-list, .conversation-content')) {
        pauseRefresh();
      }
    });

    document.body.addEventListener('scroll', function(evt) {
      if (evt.target.closest && evt.target.closest('.memory-list, .conversation-content')) {
        pauseRefresh();
      }
    }, true);

    document.body.addEventListener('wheel', function(evt) {
      if (evt.target.closest('.memory-list, .conversation-content')) {
        pauseRefresh();
      }
    }, true);

    // Restore state after swap and update step info
    document.body.addEventListener('htmx:afterSwap', function(evt) {
      // Restore memory filter state
      const scopeSelect = document.querySelector('.memory-scope-select');
      const deletedCheckbox = document.querySelector('.memory-deleted-toggle input');
      if (scopeSelect && memoryScope) scopeSelect.value = memoryScope;
      if (deletedCheckbox) deletedCheckbox.checked = showDeleted;

      // Restore auto-refresh checkbox state
      const autoRefresh = document.getElementById('autorefresh');
      const panels = document.getElementById('panels');
      if (autoRefresh && panels) {
        const isAuto = panels.getAttribute('hx-trigger')?.includes('every');
        autoRefresh.checked = isAuto;
        const stepNavEl = document.getElementById('step-nav');
        if (stepNavEl) {
          stepNavEl.classList.toggle('hidden', isAuto);
        }
      }

      // Update step navigation state from response
      const layout = document.querySelector('.layout');
      if (layout) {
        const newMaxStep = parseInt(layout.dataset.maxStep) || 0;
        if (newMaxStep > maxStep) {
          maxStep = newMaxStep;
        }
        // Only update maxStep to larger values (agent progressed)
        // If in live mode, always track latest
        if (currentStep === null) {
          maxStep = newMaxStep;
        }
      }
      updateStepDisplay();
    });

    // Long-press detection for step navigation buttons
    const LONG_PRESS_MS = 400;

    function setupStepButton(btnId, shortAction, longAction) {
      const btn = document.getElementById(btnId);
      if (!btn) return;

      let pressTimer = null;
      let longPressTriggered = false;

      btn.addEventListener('mousedown', (e) => {
        longPressTriggered = false;
        pressTimer = setTimeout(() => {
          longPressTriggered = true;
          longAction();
        }, LONG_PRESS_MS);
      });

      btn.addEventListener('mouseup', () => {
        clearTimeout(pressTimer);
        if (!longPressTriggered) {
          shortAction();
        }
      });

      btn.addEventListener('mouseleave', () => {
        clearTimeout(pressTimer);
      });

      // Touch support
      btn.addEventListener('touchstart', (e) => {
        longPressTriggered = false;
        pressTimer = setTimeout(() => {
          longPressTriggered = true;
          longAction();
        }, LONG_PRESS_MS);
      });

      btn.addEventListener('touchend', (e) => {
        clearTimeout(pressTimer);
        if (!longPressTriggered) {
          shortAction();
        }
        e.preventDefault();  // Prevent mouse events
      });
    }

    // Setup step navigation buttons with long-press
    setupStepButton('btn-back10', () => stepNav(-10), () => stepNav(-Infinity));  // Long: first
    setupStepButton('btn-back1', () => stepNav(-1), () => stepNav(-1));
    setupStepButton('btn-fwd1', () => stepNav(1), () => stepNav(1));
    setupStepButton('btn-fwd10', () => stepNav(10), () => stepNav(Infinity));     // Long: latest

    // Initialize panels URL on page load
    updatePanelsUrl();

    // CSS hot-reload: check for changes every 2s
    let lastCssModified = null;
    async function checkCssReload() {
      try {
        const resp = await fetch('/static/style.css', { method: 'HEAD' });
        const modified = resp.headers.get('Last-Modified') || resp.headers.get('ETag');
        if (lastCssModified && modified !== lastCssModified) {
          const css = document.getElementById('app-css');
          css.href = '/static/style.css?v=' + Date.now();
        }
        lastCssModified = modified;
      } catch (e) {}
    }
    setInterval(checkCssReload, 2000);
  </script>
</body>
</html>
